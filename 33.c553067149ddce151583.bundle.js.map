{"version":3,"file":"33.c553067149ddce151583.bundle.js","sources":["webpack:///../superset-ui-legacy-plugin-chart-chord/src/Chord.js"],"sourcesContent":["/* eslint-disable no-param-reassign, sort-keys, no-magic-numbers */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport d3 from 'd3';\nimport PropTypes from 'prop-types';\nimport { CategoricalColorNamespace } from '@superset-ui/color';\nimport { getNumberFormatter } from '@superset-ui/number-format';\nimport './Chord.css';\n\nconst propTypes = {\n  data: PropTypes.shape({\n    matrix: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    nodes: PropTypes.arrayOf(PropTypes.string),\n  }),\n  width: PropTypes.number,\n  height: PropTypes.number,\n  colorScheme: PropTypes.string,\n  numberFormat: PropTypes.string,\n};\n\nfunction Chord(element, props) {\n  const { data, width, height, numberFormat, colorScheme } = props;\n\n  element.innerHTML = '';\n\n  const div = d3.select(element);\n  div.classed('superset-legacy-chart-chord', true);\n  const { nodes, matrix } = data;\n  const f = getNumberFormatter(numberFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n\n  const outerRadius = Math.min(width, height) / 2 - 10;\n  const innerRadius = outerRadius - 24;\n\n  let chord;\n\n  const arc = d3.svg\n    .arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius);\n\n  const layout = d3.layout\n    .chord()\n    .padding(0.04)\n    .sortSubgroups(d3.descending)\n    .sortChords(d3.descending);\n\n  const path = d3.svg.chord().radius(innerRadius);\n\n  const svg = div\n    .append('svg')\n    .attr('width', width)\n    .attr('height', height)\n    .on('mouseout', () => chord.classed('fade', false))\n    .append('g')\n    .attr('id', 'circle')\n    .attr('transform', `translate(${width / 2}, ${height / 2})`);\n\n  svg.append('circle').attr('r', outerRadius);\n\n  // Compute the chord layout.\n  layout.matrix(matrix);\n\n  const group = svg\n    .selectAll('.group')\n    .data(layout.groups)\n    .enter()\n    .append('g')\n    .attr('class', 'group')\n    .on('mouseover', (d, i) => {\n      chord.classed('fade', p => p.source.index !== i && p.target.index !== i);\n    });\n\n  // Add a mouseover title.\n  group.append('title').text((d, i) => `${nodes[i]}: ${f(d.value)}`);\n\n  // Add the group arc.\n  const groupPath = group\n    .append('path')\n    .attr('id', (d, i) => `group${i}`)\n    .attr('d', arc)\n    .style('fill', (d, i) => colorFn(nodes[i]));\n\n  // Add a text label.\n  const groupText = group\n    .append('text')\n    .attr('x', 6)\n    .attr('dy', 15);\n\n  groupText\n    .append('textPath')\n    .attr('xlink:href', (d, i) => `#group${i}`)\n    .text((d, i) => nodes[i]);\n  // Remove the labels that don't fit. :(\n  groupText\n    .filter(function filter(d, i) {\n      /* eslint-disable-next-line babel/no-invalid-this */\n      return groupPath[0][i].getTotalLength() / 2 - 16 < this.getComputedTextLength();\n    })\n    .remove();\n\n  // Add the chords.\n  chord = svg\n    .selectAll('.chord')\n    .data(layout.chords)\n    .enter()\n    .append('path')\n    .attr('class', 'chord')\n    .on('mouseover', d => {\n      chord.classed('fade', p => p !== d);\n    })\n    .style('fill', d => colorFn(nodes[d.source.index]))\n    .attr('d', path);\n\n  // Add an elaborate mouseover title for each chord.\n  chord\n    .append('title')\n    .text(\n      d =>\n        `${nodes[d.source.index]} → ${nodes[d.target.index]}: ${f(d.source.value)}\\n${\n          nodes[d.target.index]\n        } → ${nodes[d.source.index]}: ${f(d.target.value)}`,\n    );\n}\n\nChord.displayName = 'Chord';\nChord.propTypes = propTypes;\n\nexport default Chord;\n"],"mappings":"AAyBA","sourceRoot":""}